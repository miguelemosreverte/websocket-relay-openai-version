package main

import (
    "encoding/json"
    "flag"
    "fmt"
    "io/ioutil"
    "os"
)

func main() {
    in := flag.String("in", "", "Input JSON file")
    out := flag.String("out", "site/index.html", "Output HTML file")
    title := flag.String("title", "Benchmark Report", "Page title")
    flag.Parse()
    if *in == "" {
        fmt.Fprintln(os.Stderr, "-in is required")
        os.Exit(2)
    }
    b, err := ioutil.ReadFile(*in)
    if err != nil { panic(err) }
    var v map[string]any
    if err := json.Unmarshal(b, &v); err != nil { panic(err) }

    // Embed the JSON directly into the page for Chart.js to consume
    html := fmt.Sprintf(`<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>%s</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;max-width:960px;margin:40px auto;padding:0 16px;color:#222}
    header{margin-bottom:16px}
    .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px}
    .card{border:1px solid #ddd;border-radius:8px;padding:12px}
    canvas{max-width:100%;}
    footer{margin-top:24px;color:#666;font-size:12px}
    pre{white-space:pre-wrap;word-break:break-word}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    const DATA = %s;
  </script>
  </head>
  <body>
    <header>
      <h1>%s</h1>
      <div id="meta"></div>
    </header>
    <section class="stats" id="stats"></section>
    <section>
      <h2>Time Series</h2>
      <canvas id="chart"></canvas>
    </section>
    <footer>
      Generated by render.go
    </footer>
    <script>
      function fmt(n){return new Intl.NumberFormat().format(n)}
      function el(tag, cls, txt){const e=document.createElement(tag); if(cls)e.className=cls; if(txt)e.textContent=txt; return e}
      function card(label, value){const c=el('div','card'); c.append(el('div','label',label)); c.append(el('div','value',value)); return c}
      const meta=document.getElementById('meta');
      meta.textContent = `Commit ${DATA.commit || 'dev'} â€¢ Build ${DATA.build_time || 'dev'}`;
      const stats=document.getElementById('stats');
      stats.append(
        card('Duration (s)', (DATA.duration_sec||0).toFixed(1)),
        card('Clients', DATA.clients||0),
        card('Sent', fmt(DATA.total_sent||0)),
        card('Received', fmt(DATA.total_received||0)),
        card('Avg Latency (ms)', (DATA.avg_latency_ms||0).toFixed(2)),
        card('P50 (ms)', (DATA.p50_ms||0).toFixed(2)),
        card('P95 (ms)', (DATA.p95_ms||0).toFixed(2)),
        card('Bytes Sent', fmt(DATA.bytes_sent||0)),
        card('Bytes Received', fmt(DATA.bytes_received||0)),
      );
      const labels = (DATA.series||[]).map(p => p.second);
      const sent = (DATA.series||[]).map(p => p.sent);
      const recv = (DATA.series||[]).map(p => p.received);
      const lat = (DATA.series||[]).map(p => p.avg_latency_ms);
      const ctx=document.getElementById('chart');
      new Chart(ctx, {
        type:'line',
        data:{
          labels,
          datasets:[
            {label:'Sent', data:sent, borderColor:'#0b84a5', fill:false},
            {label:'Received', data:recv, borderColor:'#f6c85f', fill:false},
            {label:'Avg Latency (ms)', data:lat, borderColor:'#e45756', fill:false, yAxisID:'y1'},
          ]
        },
        options:{
          interaction:{mode:'index', intersect:false},
          stacked:false,
          scales:{
            y: {type:'linear', position:'left'},
            y1:{type:'linear', position:'right'}
          }
        }
      });
    </script>
  </body>
</html>`, *title, string(b), *title)

    if err := os.MkdirAll(filepathDir(*out), 0o755); err != nil { panic(err) }
    if err := os.WriteFile(*out, []byte(html), 0o644); err != nil { panic(err) }
}

func filepathDir(p string) string {
    if di, err := os.Stat(p); err == nil && di.IsDir() {
        return p
    }
    return filepathDirRaw(p)
}

func filepathDirRaw(p string) string {
    // minimal dir extraction to avoid importing path/filepath for tiny tool
    i := len(p)-1
    for i >= 0 && p[i] != '/' { i-- }
    if i <= 0 { return "." }
    return p[:i]
}

